<div class="col-md-6">
		
		<section class="preHeader">
		 	<h2>Lesstof week 3 - WPF Basics</h2>
		</section>
		
		<article class="sample shadow-z-1" id="inleiding">
			<section class="header">
				<span>Inleiding</span>
			</section>
			
			<section class="main">
				
				Wat gaan we deze week doen?
				
			</section>
			
			<section class="footer">
				
				
			</section>
		
		</article>
		
		<article class="sample shadow-z-1" id="xaml">
			<section class="header">
				<span>XAML</span>
			</section>
			
			<section class="main">
				
				<div class="row">
					<div class="col-md-9">
						<p>
							Bij het 
							aanmaken van een nieuw WPF project krijg je gratis 2 XAML files. <br/>
							De vereiste <strong>App.xaml</strong> en een <strong>MainWindow.xaml</strong>. Beide XAML files bevatten een code-behind .cs file.
						</p>
						
						<p>
							De aangeleverde MainWindow.xaml file bevat al standaard een titel, breedte, hoogte en Grid als child element. 
							Nu kunnen we zelf een elementenboom gaan opbouwen in deze grid om een volledige user interface te krijgen.
							Deze boom bestaat uit <strong>XAML elementen</strong>.
						</p>
				
						<p>
							Elk XAML element bevat een bijbehorende referentie naar een .NET class. Je kunt dus ook zelf een class omzetten naar een XAML element.
							De meest voorkomende manier waarop dit gebeurt zijn <strong>user controls</strong>.
							Het .NET framework bevat al een grote lijst aan voorgedefinieerde classes.
						</p>
				
						<p>
							Om onze user interface te implementeren kunnen we een onderscheid maken tussen 2 soorten elementen.
							Hieronder volgen een aantal voorbeelden van beide typen elementen.
						</p>
				
					</div>
					<div class="col-md-3">
						<img src="week3/img/XAMLFiles.png" class="img-thumbnail center-block" />
					</div>
				</div>
			</section>
		</article>
		
		<!-- Code examples --> 
		<div class="row">
       	 <div class="col-md-6">
				
				<article class="sample shadow-z-1 codexamp" ng-controller="hoverCtrl" >
					<section class="header">
						<span>Containers</span>
						<i class="mdi-action-info" style="font-size: 24pt;"></i>
					</section>
			
					<section class="main">
						<p>
							Deze elementen hebben de eigenschap dat ze bedoeld zijn om andere elementen te positioneren. 
							Ze hebben over het algemeen geen 'styling'. Daarnaast kunnen andere elementen doormiddel van 
							'attached properties' hun positie afhankelijk maken van deze containers.
						</p>
					</section>
				</article>
				
				<!-- Dockpanel -->
				<article class="sample shadow-z-1 codexamp" ng-controller="hoverCtrl" >
					<section class="header">
						<span>DockPanel</span>
						<i class="mdi-image-photo" style="font-size: 24pt;" ng-mouseover="show()" ng-mouseleave="hide()" ng-click="toggle()" ng-class="{active: isShowing}"></i>
						
					</section>
			
					<section class="main">
						
<!-- Code Snippet -->
<pre class="prettyprint linenums" >
&lt;DockPanel Width=&quot;100&quot; Height=&quot;50&quot;&gt;
  &lt;Button Content=&quot;A&quot; DockPanel.Dock=&quot;Left&quot; 
    Width=&quot;50&quot;/&gt;
  &lt;Button Content=&quot;B&quot; DockPanel.Dock=&quot;Right&quot; 
    Width=&quot;50&quot;/&gt;
&lt;/DockPanel&gt;</pre>
                              <!-- End of Snippet -->
							  
						<img src="week3/img/dockpanel.png" class="animate-show" ng-show="isShowing"/>
						
				</section>	
			</article>
			<!-- end of dockpanel -->
			
			<!-- Wrappanels -->
			 <article class="sample shadow-z-1 codexamp" ng-controller="hoverCtrl" >
					<section class="header">
						<span>WrapPanels</span>
						<i class="mdi-image-photo" style="font-size: 24pt;" ng-mouseover="show()" ng-mouseleave="hide()" ng-click="toggle()" ng-class="{active: isShowing}"></i>
						
					</section>
			
					<section class="main">
						
<!-- Code Snippet -->
<pre class="prettyprint linenums"  >&lt;WrapPanel Width=&quot;100&quot; Height=&quot;60&quot;&gt;
   &lt;Button Content=&quot;Left&quot; Width=&quot;50&quot;/&gt;
   &lt;Button Content=&quot;Right&quot; Width=&quot;50&quot;/&gt;
   &lt;Button Content=&quot;Left&quot; Width=&quot;30&quot;/&gt;
   &lt;Button Content=&quot;Right&quot; Width=&quot;70&quot;/&gt;
   &lt;Button Content=&quot;Right&quot; Width=&quot;100&quot;/&gt;
&lt;/WrapPanel&gt;</pre>
                              <!-- End of Snippet -->
							  
							<img src="week3/img/wrappanel.png"  class="animate-show"ng-show="isShowing"/>
							  
					</section>
					

						
				</article>
			<!-- Stackpanel -->
			<article class="sample shadow-z-1 codexamp" ng-controller="hoverCtrl" >
				<section class="header">
					<span>StackPanel</span>
					<i class="mdi-image-photo" style="font-size: 24pt;" ng-mouseover="show()" ng-mouseleave="hide()" ng-click="toggle()" ng-class="{active: isShowing}"></i>
					
				</section>
		
				<section class="main">
					
<!-- Code Snippet -->
<pre class="prettyprint linenums"  >
&lt;StackPanel Width=&quot;100&quot; Height=&quot;120&quot;&gt;
  &lt;Button Content=&quot;Left&quot; Width=&quot;50&quot;/&gt;
  &lt;Button Content=&quot;Right&quot; Width=&quot;50&quot;/&gt;
  &lt;Button Content=&quot;Left&quot; Width=&quot;30&quot;/&gt;
  &lt;Button Content=&quot;Right&quot; Width=&quot;70&quot;/&gt;
  &lt;Button Content=&quot;Right&quot; Width=&quot;100&quot;/&gt;
&lt;/StackPanel&gt;</pre>
							<!-- End of Snippet -->
							
						<img src="week3/img/stackpanel.png"  class="animate-show"ng-show="isShowing"/>
							
				</section>
			</article>
		<!-- end of stackpanel -->
	 		<!-- Grid -->
			<article class="sample shadow-z-1 codexamp" ng-controller="hoverCtrl" >
				<section class="header">
					<span>Grid</span>
					<i class="mdi-image-photo" style="font-size: 24pt;" ng-mouseover="show()" ng-mouseleave="hide()" ng-click="toggle()" ng-class="{active: isShowing}"></i>
					
				</section>
		
				<section class="main">
					
<!-- Code Snippet -->
<pre class="prettyprint linenums"  >
&lt;Grid Width=&quot;100&quot; Height=&quot;50&quot;&gt;
  &lt;Grid.RowDefinitions&gt;
    &lt;RowDefinition /&gt;
  &lt;/Grid.RowDefinitions&gt;
  &lt;Grid.ColumnDefinitions&gt;
    &lt;ColumnDefinition /&gt;
    &lt;ColumnDefinition /&gt;
  &lt;/Grid.ColumnDefinitions&gt;
   
 &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; 
    Content=&quot;A&quot; /&gt;
 &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; 
    Content=&quot;B&quot; /&gt;
&lt;/Grid&gt;</pre>      
							<!-- End of Snippet -->
							
						<img src="week3/img/Grid.png"  class="animate-show"ng-show="isShowing"/>
							
				</section>
			</article>
			<!-- end of Grid -->
			<!-- Border -->
			<article class="sample shadow-z-1 codexamp" ng-controller="hoverCtrl" >
				<section class="header">
					<span>Border</span>
					<i class="mdi-image-photo" style="font-size: 24pt;" ng-mouseover="show()" ng-mouseleave="hide()" ng-click="toggle()" ng-class="{active: isShowing}"></i>
					
				</section>
		
				<section class="main">
					
<!-- Code Snippet -->
<pre class="prettyprint linenums"  >
&lt;Border BorderThickness=&quot;5&quot; 
  BorderBrush=&quot;Green&quot;
  Width=&quot;50&quot; Height=&quot;50&quot;&gt;
     &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; 
	   Content=&quot;A&quot; /&gt;
&lt;/Border&gt;</pre>   
							<!-- End of Snippet -->
							
						<img src="week3/img/border.png"  class="animate-show"ng-show="isShowing"/>
							
				</section>
			</article>
			<!-- end of Border -->
		</div>
		<div class="col-md-6">
		
			<article class="sample shadow-z-1 codexamp" ng-controller="hoverCtrl" >
					<section class="header">
						<span>User Controls</span>
						<i class="mdi-action-info" style="font-size: 24pt;"></i>
						
					</section>
			
					<section class="main">
						<p>
							Deze elementen hebben een functie binnen je pagina. Of ze tonen informatie, of geven de gebruiker de mogelijkheid input te leveren. 
						</p><p>
							De C# code die je ziet is gelinkt aan een event vanuit de XAML.
						</p>
					</section>
				</article>
		
			<!-- Button -->
			<article class="sample shadow-z-1 codexamp" ng-controller="hoverCtrl" >
				<section class="header">
					<span>Button</span>
					<i class="mdi-image-photo" style="font-size: 24pt;" ng-mouseover="show()" ng-mouseleave="hide()" ng-click="toggle()" ng-class="{active: isShowing}"></i>
					
				</section>
		
				<section class="main">
					
                             <!-- Code Snippet -->
                            <pre class="prettyprint linenums"  >
&lt;Button Content=&quot;A&quot; Click=&quot;ClickA&quot;&gt;&lt;/Button&gt;</pre>
                              <!-- End of Snippet -->
                      
                            <!-- Code Snippet -->
                            <pre class="prettyprint linenums"  >
private void ClickA(object sender, RoutedEventArgs e)
{
    //Add Behavior here
}
</pre>
                       
							<!-- End of Snippet -->
							
						<img src="week3/img/button.png"  class="animate-show"ng-show="isShowing"/>
							
				</section>
			</article>
			<!-- end of Button -->
			
			<!-- listbox -->
			<article class="sample shadow-z-1 codexamp" ng-controller="hoverCtrl" >
				<section class="header">
					<span>listbox</span>
					<i class="mdi-image-photo" style="font-size: 24pt;" ng-mouseover="show()" ng-mouseleave="hide()" ng-click="toggle()" ng-class="{active: isShowing}"></i>
					
				</section>
		
				<section class="main">
					
<!-- Code Snippet -->
<pre class="prettyprint linenums"  >
&lt;ListBox Name=&quot;Listy&quot;&gt;
  &lt;ListBoxItem&gt;Item 1&lt;/ListBoxItem&gt;
  &lt;ListBoxItem&gt;Item 2&lt;/ListBoxItem&gt;
&lt;/ListBox&gt;</pre>
<!-- End of Snippet -->

<!-- Code Snippet -->
<pre class="prettyprint linenums"  >
Listy.Items.Add(new ListBoxItem
{
	Content = &quot;Item 3&quot;
});</pre>
<!-- End of Snippet -->
							
						<img src="week3/img/listbox.png"  class="animate-show"ng-show="isShowing"/>
							
				</section>
			</article>
			<!-- end of listbox -->
	
			<!-- TextBox -->
			<article class="sample shadow-z-1 codexamp" ng-controller="hoverCtrl" >
				<section class="header">
					<span>Textbox</span>
					<i class="mdi-image-photo" style="font-size: 24pt;" ng-mouseover="show()" ng-mouseleave="hide()" ng-click="toggle()" ng-class="{active: isShowing}"></i>
					
				</section>
		
				<section class="main">
					    
                            <!-- Code Snippet -->
                            <pre class="prettyprint linenums"   >
&lt;Grid Width=&quot;100&quot; Height=&quot;50&quot;&gt;
    &lt;TextBox Name=&quot;Boxy&quot; Text=&quot;Hell world&quot; 
    TextChanged=&quot;TextBox_TextChanged&quot;&gt;&lt;/TextBox&gt;
&lt;/Grid&gt;</pre>
                              <!-- End of Snippet -->

                             <!-- Code Snippet -->
                            <pre class="prettyprint linenums"  >
private void TextBox_TextChanged(object sender, TextChangedEventArgs e)
{
    Console.WriteLine(Boxy.Text);
};</pre>
                              <!-- End of Snippet -->
                      	
						<img src="week3/img/textbox.png"  class="animate-show"ng-show="isShowing"/>
						<img src="week3/img/output.png"  class="animate-show"ng-show="isShowing"/>
				</section>
			</article>
			<!-- end of Textbox -->
			
		</div>
	</div>
	
	<article class="sample shadow-z-1" id="binding">
				<section class="header">
					<span>Binding</span>
				</section>
				
				<section class="main">
					
					
					
					
			
    <h4>Wat is Data-binding?</h4>
    
    <p>Data-binding is een verbinding tussen je graphical user interface en je bedrijfslogica. WPF bevat een aantal componenten die je kunt instellen om XAML
    elementen de waarde van een model te laten reflecteren. Als een property van het model verandert, veranderen alle XAML elementen met een binding op die property mee. 
    </p>
    
    <p>In de voorbeelden van XAML code in het vorige blok, werd getoond dat je de XAML elementen via C# code kan bereiken en 
        eventuele waardes of collecties kan aanpassen. De verantwoordelijkheid om de veranderingen op het model door te voeren in de view, 
        moet losgekoppeld worden van de bedrijfslogica. 
        Data-binding is hier de perfecte oplossing voor.
    </p>
    
	<div class="text center" width="100%">
		  <img src="week3/img/data-binding.png"/>
	</div>
 

    <h3 class="top-buffer">Binding in WPF</h3>
    
    <p>
        We hebben een aantal dingen nodig om data-binding aan de praat te krijgen.
        
        <ul>
            <li>Een XAML element om de data te tonen</li>
            <li>Een Model met waardes waar we de 'view' tegen aan kunnen binden</li>
        </ul>
    </p>
    
    <p></p>
    
    <div class="row">
        <div class="col-md-6">
            
            <h4>Model</h4>
            <!-- code snippet -->
            <pre class="prettyprint linenums">
public class TemperatureVM{
     private double _temperature;
}</pre>
        </div>
        <div class="col-md-6">
            
            <h4>XAML Element</h4>
            <!-- code snippet -->
            <pre class="prettyprint linenums">
 &lt;Label Content=&quot;The temperature is&quot;/&gt;
 &lt;Label&gt;Hier wil ik de temperatuur hebben&lt;/Label&gt;</pre>
        </div>
    </div>
    
    <p>
        Eerst moeten we de view vertellen op wat voor model hij zijn waardes kan baseren. Dit doen we met de <strong>Window.DataContext</strong> property. 
        Hiermee kunnen we aangeven welke data onze view gaat gebruiken. Er zijn twee manieren om dit te realiseren. 
        <ul>
            <li>Declaratief</li>
            <li>Code-behind</li>
        </ul>
        Het doel van data-binding is om zo min mogelijk verwijzingen vanuit je code naar de view te maken. Als je de referentie vanuit de code-behind
        file maakt dan leg je weer een sterke verbinding tussen je code en je view. Het is dus netter dit vanuit de view (declaratief) op te lossen.
    </p>

    <p>
        Om dit te realiseren moet je wel toegang hebben tot de namespace waar de data (je model of view model) zich bevind. Je kunt toegang tot een namespace
        verlenen door een referentie toe te voegen in je window met het <strong>xmlns</strong> attribuut. 
        Je kunt elke include een eigen naam geven zodat je via deze naam de onderliggende classes kunt benaderen. 
        In het voorbeeld noem ik de namespace 'local'.
    </p>
    
    
    <div class="row">
        <div class="col-md-6">
            
            <h4>Declaratief</h4>
            
            <!-- code snippet -->
            <pre class="prettyprint linenums">
xmlns:local=&quot;clr-namespace:CommandingAndBindingDemo&quot;</pre>
            <!-- end of snippet -->
            
            <!-- code snippet -->
            <pre class="prettyprint linenums">
&lt;Window.DataContext&gt;
    &lt;local:TemperatureVM /&gt;
&lt;/Window.DataContext&gt;</pre>
        </div>
        <div class="col-md-6">
            
            <h4>Code-behind</h4>
            <!-- code snippet -->
            <pre class="prettyprint linenums">
public MainWindow()
{
    InitializeComponent();
    DataContext = new TemperatureVM();
}</pre>
        </div>
    </div>    


    <p>Als laatste stap moeten we in het Model een Public Property maken die voldoet aan de eisen van het WPF data-binding framework. 
        Daarnaast moeten we een referentie vanuit de view naar deze property leggen.
    </p>

             <p>Om te voldoen aan de eisen van WPF moeten we van ons model (wat op dit moment al een view model is ) laten overerven van het interface  
                <strong>INotifyPropertyChanged</strong>. Dit geeft ons toegang tot de data-binding eigenschappen van WPF.
             </p>
            <p>
                Voor ieder property op je model zul je moeten aangeven dat de waarde gewijzigd is. Hierdoor zal automatisch de view ge&uuml;pdatet worden.
                Het aangeven van een wijziging doe je via het event <strong>RaisePropertyChanged</strong>. De meegegeven naam moet overeenkomen met de naam
                die je hebt aangegeven in je XAML element.
            </p>    

            <p>
                Het <strong>RaisePropertyChanged</strong> event gaat op zoek naar alle XAML elementen die een binding hebben openstaan met de meegegeven property. 
                Om deze reden moet er ook een null check aanwezig zijn. Het kan namelijk zo zijn dat er geen enkel element 'gebind' is aan de gewijzigde property.
                Je hoeft deze event handler maar 1x aan te maken, en je hier verder geen zorgen over te maken.
            </p>


    <div class="row">
        <div class="col-md-6">
           
            <p>
                Als nu de waardes op het model veranderen, verandert de view automatisch mee. 
                Vanaf dit punt is het dus ook heel makkelijk om bijvoorbeeld een textveld toe te voegen waar de gebruiker de waarde van de temperatuur kan aanpassen.
                Je hoeft alleen in het XAML element aan te geven dat je de waarde van het textveld wilt data-binden aan de temperatuur. 
                In het voorbeeld geef ik ook aan <strong>wanneer</strong> de property Temperature geupdate moet worden via het binding attribuut 
                <strong>UpdateSourceTrigger</strong>. 
            </p>
        </div>
        <div class="col-md-6">
            
            <h4>Data-binding vanuit XAML</h4>
            
            <!-- code snippet -->
            <pre class="prettyprint linenums">
&lt;Label Content=&quot;The temperature is&quot;/&gt;
&lt;Label Content=&quot;{Binding Temperature}&quot;&gt;&lt;/Label&gt;
&lt;TextBox Text=&quot;{Binding Temperature, UpdateSourceTrigger=PropertyChanged}&quot; /&gt;</pre> 
            
            <!-- code snippet -->

        </div>
    </div>   

            <pre class="prettyprint linenums">
public class TemperatureVM : INotifyPropertyChanged
{
    private double _temperature;

    public double Temperature 
    {
        get { return _temperature; }
        set
        {
            _temperature = value;
            RaisePropertyChanged(&quot;Temperature&quot;);
        }
    }
    
    #region INotifyPropertyChanged Members

    void RaisePropertyChanged(string prop)
    {
        if (PropertyChanged != null) { PropertyChanged(this, new PropertyChangedEventArgs(prop)); }
    }

    public event PropertyChangedEventHandler PropertyChanged;

    #endregion
    
}
</pre>

    


        <h4>Bronnen</h4>
        <ul>
            <li><a href=" http://msdn.microsoft.com/en-us/library/ms752347(v=vs.110).aspx"> http://msdn.microsoft.com/en-us/library/ms752347(v=vs.110).aspx</a></li>
        </ul>
		
					
					
					
					
					
					
					
					
					
					
				</section>
			</article>
			
			<article class="sample shadow-z-1" id="commanding">
				<section class="header">
					<span>Commanding</span>
				</section>
				
				<section class="main">
					
					
		 <h3>Commanding</h3>


  <p>In de uitleg over Binding werd als voorbeeld een property <strong>Temperature</strong> 'gebind' aan een Label. De uitleg in dit hoofdstuk bouwt verder op de voorbeelden uit het hoofdstuk <strong>Binding</strong>.
    </p>
    
  <p>
     Als we willen dat er een stuk logica uitgevoerd wordt op het model, willen we niet dat de logica weet dat er bijvoorbeeld een 'knop' is die deze logica uitvoert. 
     Nu is dit gemakkelijk te voorkomen door alleen een referentie vanuit de view naar het model te leggen. Bijvoorbeeld een event-handler zoals beschreven in de voorbeelden in het hoofdstuk <strong>XAML</strong>.
  </p>
    
    <p>
        Het is daarentegen mogelijk dat de actie die de functie op het model 'triggert' op verschillende manieren aangeroepen kan worden. Denk bijvoorbeeld aan een actie zoals knippen en plakken. Dit kan vanuit een menu, ctrl-c > ctrl-v, rechtermuisknop, etc..
    </p>
    
    <p>
        WPF biedt je de mogelijkheid de getriggerde actie los te koppelen van de uit te voeren logica. Dit heet een <strong>Command</strong>.
    </p>

    
    <h3>De code</h3>
    
    <p>
        Een <strong>Command</strong> in WPF is een voorgedefinieerde .NET interface die je toe kan voegen op je model. Je maakt dan de command verantwoordelijk voor de                 aanpassingen op je model, of tot het uitvoeren van een functie op je model. Op regel 18 van de onderstaande code snippit staat de verwijzing naar een implementatie van het interface
        <strong>ICommand</strong> met de naam SetLowCommand.
    </p>
    
    <h4>View Model</h4>
    
    <!-- code snippet -->
    <pre class="prettyprint linenums">
public class TemperatureVM : INotifyPropertyChanged
{
    /// &lt;summary&gt;
    /// Privates, getters en setters for temparture
    /// &lt;/summary&gt;
    private double _temperature;

    public double Temperature 
    {
        get { return _temperature; }
        set
        {
            _temperature = value;
            RaisePropertyChanged(&quot;Temperature&quot;);
        }
    }

    public ICommand SetLowCommand { get; set; }

    /// &lt;summary&gt;
    /// Constructor!
    /// &lt;/summary&gt;
    public TemperatureVM()
    {
        this._temperature = 22;
        //Maak een nieuw SetLowCommand aan
        SetLowCommand = new SetLowCommand(this);
    }

    ///
    #region INotifyPropertyChanged Members

    void RaisePropertyChanged(string prop)
    {
        if (PropertyChanged != null) { PropertyChanged(this, new PropertyChangedEventArgs(prop)); }
    }

    public event PropertyChangedEventHandler PropertyChanged;

    #endregion

}</pre>
    <!-- End of code snippet -->
            
    <h3>ICommand</h3>
    
    <p>
        Command objecten bestaan uit 4 onderdelen:
        <ul>
            <li>Constructor</li>
            <li>CanExecute</li>
            <li>Execute</li>
            <li>CanExecuteChanged</li>
        </ul>
    
        De <strong>Constructor</strong> is de beste plaats om toegang tot ons view model te krijgen. Geef het View Model mee als parameter, en sla hem op als
        private field. De <strong>CanExecute</strong> method bepaalt of het commando uitgevoerd kan worden. Bepaalde XAML elementen zullen ge-disabled worden indien 
    CanExecute false returnt. De <strong>Execute</strong> methode voert uiteindelijk de bedrijfslogica uit.
    </p>
    
    <p>
        Het <strong>CanExecuteChanged</strong> event kun je vergelijken met het <strong>RaisePropertyChanged</strong> uit het hoofdstuk binding.
        Het kan zo zijn dat er meerdere knoppen een binding hebben met je gedefinieerde command. Het <strong>CanExecuteChanged</strong> event zorgt er voor dat
        alle XAML elementen ge&uuml;pdatet worden wanneer de waarde van <strong>CanExecute</strong> wijzigt.
    </p>
            
    <h4>SetLowCommand</h4>
            
    <!-- code snippet -->
    <pre class="prettyprint linenums">
class SetLowCommand : ICommand
{
    private TemperatureVM viewmodel;

    public SetLowCommand(TemperatureVM viewmodel)
    {
        this.viewmodel = viewmodel;
    }

    public bool CanExecute(object parameter)
    {
        if(viewmodel == null)
        {
            return false;
        }
        else
        {
            return viewmodel.Temperature &gt; 10;
        }
    }

    public void Execute(object parameter)
    {
        viewmodel.Temperature = 0;
    }

    public event EventHandler CanExecuteChanged
    {
        add { CommandManager.RequerySuggested += value; }
        remove { CommandManager.RequerySuggested -= value; }
    }
}</pre>            
    
    <h4>Bronnen</h4>
    <ul>
        <li><a href="http://msdn.microsoft.com/en-us/library/ms752308(v=vs.110).aspx">http://msdn.microsoft.com/en-us/library/ms752308(v=vs.110).aspx</a></li>
    </ul>			
					
					
					
					
					
				</section>
			</article>
			
			<article class="sample shadow-z-1" id="converting">
				<section class="header">
					<span>Converting</span>
				</section>
				
				<section class="main">
					
					<h3>Converting</h3>
  
   <p>Het kan zo zijn dat je nog een stukje logica op je 'data' wilt uitvoeren voordat je deze toont in de view. 
    Nu is het de vraag of deze logica nu bij de view hoort, of bij het model. Het antwoord is <strong>geen van beiden</strong>. 
       (pa pa pa paaaaah)*
    </p>
    
    <p>
        <i>*shock effect</i>
    </p>
    
    <p>
        <strong>#SOC</strong> is hip en trending. Ook in dit geval willen we onze logica lostrekken uit de view, maar ook uit het model. 
        Dit is de plek waar we <strong>Converters</strong> kunnen gebruiken.  
    </p>
    

    <div class="row top-buffer">
        <div class="col-md-8">
            
            <h4>IValueConverter</h4>
            <p>De WPF library bevat een interface genaamd <strong>IValueConverter</strong> met een methode <strong>Convert</strong> en een 
                methode <strong>ConvertBack</strong>. Deze method's hebben een input parameter van het type object, en een return value van het type object.
                Hier kun je eventuele logica in kwijt voor het bewerken van je data die uitgevoerd wordt tijdens de two-way binding.     
            </p>
                     
            <img class="top-buffer" src="week3/img/valueconverters.png" />

            <p class="top-buffer">
                Naast een collectie van voorgedefinieerde converters kun je dus ook je eigen converter bouwen volgens de regels hierboven. 
                Je kunt zelf een klasse uitbreiden met de interface <strong>IValueConverter</strong> en de bijbehorende methodes implementeren. 
                Je kunt nu je eigen logica kwijt in deze converter.
            
            </p>
          
        </div>
        
        
        <div class="col-md-4">
            
            <div class="panel panel-default">
                
                <div class="panel-heading">
                    <h3 class="panel-title">Default Converters</h3>
                </div>
                     
                <div class="panel-body">
                     <strong>In System.Windows.Control</strong> (PresentationFramework.dll)

                    <ul>
                         <li>AlternationConverter</li>
                         <li>BooleanToVisibilityConverter</li>
                         <li>BorderGapMaskConverter</li>
                         <li>DataGridLengthConverter</li>
                         <li>MenuScrollingVisibilityConverter</li>
                     </ul>                    

                     <strong>In System.Windows.Documents</strong>
                      <ul>
                         <li>ZoomPercentageConverter</li>
                         <li>JournalEntryListConverter</li>
                     </ul>
                    
                     <strong>In Microsoft.Windows.Themes</strong>
                     <ul>
                        <li>ProgressBarBrushConverter</li>
                        <li>ProgressBarHighlightConverter</li>
                     </ul>

                     <strong>In System.Windows.Navigation</strong>
                     <ul>
                        <li>JournalEntryUnifiedViewConverter</li>
                     </ul>
                    
                </div>
            </div>
            
            
        </div>
    </div>
    
    <!-- Code Snippet -->
     <pre class="prettyprint linenums">
class DegreesToAngleConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
    {
        //In deze methode wordt de temperatuur naar de juiste hoek geconverteerd voor het plaatje zodat de temp overeenkomt.
        //De waardes zijn door 'trial and error' aangepast zodat het lijkt dat de meter op de juiste temp staat
        double result = (double)value;
        return result * 2.30 - 63.049;
    }

    public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
    {
        //De convert back is niet nodig. 
        return value;
    }
}</pre>
    <!-- End -->
    

    <p>
        Hierna kun je deze converter gebruiken in je project. Je kunt vanuit de XAML code aangeven dat je een converter 
        wilt toepassen op een bepaalde binding. In het voorbeeld wordt een XAML element genaamd <strong>Image.RenderTransform</strong> gebruikt om het plaatje
        onder een bepaalde hoek te draaien. Deze hoek kun je terugvinden in het element <strong>RotateTransform</strong> onder het atribuut <strong>Angle</strong>.
        Hier wordt naast een <strong>Binding</strong> ook een <strong>Converter</strong> gegeven met de verwijzing naar een static resource.
        Het is namelijk niet mogelijk om rechtstreeks een verwijzing naar de gedefinieerde class te maken. We moeten deze class toegankelijk maken in de vorm van een
        <strong>Resource</strong>.
    </p>
    
    <h4>Converter Resource</h4>
    
    <p>Met een referentie naar je gedefinieerde class en een naam om hem terug te vinden (key). </p>
    
    <pre class="prettyprint linenums">
&lt;Window.Resources&gt;
     &lt;local:DegreesToAngleConverter x:Key=&quot;converter&quot; /&gt;
 &lt;/Window.Resources&gt;</pre>

    <h4>XAML</h4>
    
    <p>Een van de manieren om een converter in te zetten. Bij elke binding kun je een eventuele converter mee geven.</p>
    
    <pre class="prettyprint linenums">
&lt;Image Panel.ZIndex=&quot;2&quot; Height=&quot;32&quot; Source=&quot;rotate.png&quot; Stretch=&quot;Fill&quot; Width=&quot;114&quot; Canvas.Left=&quot;37&quot; Canvas.Top=&quot;78&quot; RenderTransformOrigin=&quot;0.5,0.5&quot;&gt;
    &lt;Image.RenderTransform&gt;
        &lt;TransformGroup&gt;
            &lt;ScaleTransform/&gt;
            &lt;SkewTransform/&gt;
                &lt;RotateTransform Angle=&quot;{Binding Temperature, Converter={StaticResource converter}}&quot;/&gt;
            &lt;TranslateTransform/&gt;
        &lt;/TransformGroup&gt;
    &lt;/Image.RenderTransform&gt;
&lt;/Image&gt;</pre>
					
					
					
					
				</section>
			</article>
	
</div>

 <!-- Deze regel javascript hebben we nodig voor het 'prettifyen' van onze code snippits -->
    <script>
        
      !function ($) {
        $(function(){
          window.prettyPrint && prettyPrint()   
        })
      }(window.jQuery)
      
    </script>